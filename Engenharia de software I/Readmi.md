"We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. 
On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. 
In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. 
Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth. 
Within Google, we sometimes say, “Software engineering is programming integrated over time.” 
Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. 
If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) 
and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. 
Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming."

Titus Winters, Software Engineering at Google

<i><h5> Engenharia de Software </h5></i>

Um bom software deve ser construído com uma boa estrutura, pois não devemos pensar apenas no nascimento de um software, mas como vai funcionar a longo prazo? como vai ser a manutenção desse código? está bem comentando para futuras correções? é um código limpo? tudo isso deve ser levado em conta quando criamos um software, pois não envolve apenas a programação, mas o raciocínio da estrutura ao todo. As linguagens de programação deve ser levado em conta para cada tipo de software, pois cada linguagem de programação tem sua vantagem e desvatagem para determinados softwares. Apenas a programação não é o suficiente para um bom software, mas devemos olhar toda sua estrutura, ferramentas, documentação etc...


<i><h5> Trade Off </h5></i>


Qualquer projeto que seja, devemos levar em conta quais ferramenta utilizar. Um engenheiro civil precisa analisar quais ferramentas e materiais utilizar, para cada tipo de construção. Precisa ser um projeto que necessita de uma entrega rápida sem manutenção? Ou um projeto para usar a longo prazo, que necessita de correções ao longo do tempo. Cada uma das diversas ferramentas e materiais, deve ser analisado ao criar um projeto, qual é a suas vantagens e desvantagens para o projeto.
Um confeiteiro ao criar um bolo, deve levar em conta quais marcas de ingredientes usar para o bolo, precisa ser um bolo doce ou não? Um bolo fofo? Consistente ou mole. 

<i><h5> Ciclo de vida do desenvolvimento de software </h5></i>

Uma empresa de telemarketing, o qual atende linhas pré-pago está com um grande fluxo de ligações nos últimos tempos, e para resolver esse problema, eles resolveram criar um software básico para seus clientes, o qual o usuário consegue resolver seu problema de uma forma prática e eficiente. Primeiramente eles fazem uma análise sobre as ligações, quais são as maiores solicitações e reclamações de seus clientes, e logo após essa análise, eles iniciam a criação do software com alguns requisitos básicos. Fazem a definição dos requisitos funcionais e não funcionais do sistema, e criam um protótipo desse software, analisam a melhor linguagem de programação para o software ter um bom desempenho, e pensam em uma estrutura de dados do código o qual eles podem fazer uma futura manutenção de uma forma eficiente.

1.	Interface de login front-end: Definir boa cores, deixando um ambiente prático e bonito o qual o cliente consegue enxergar tudo perfeitamente, e chamar atenção de clientes novos que irá utilizar o software futuramente. Adicionar instruções para os usuários, de como acessar o login e de como realizar um cadastro caso não tenha um login ainda.
2.	Interface de configurações e informações sobre os planos e promoções: Boas cores, instrução de como usar o canal de configurações e informações, utilizar imagens com base em experiência real dos usuários, um site limpo o qual o cliente não fique perdido. 
3.	Interface de reclamação: Boas cores, instruções de como utilizar o canal de reclamações, informações sobre quando realizar uma reclamação ou não, solicitando alguns testes antes de abrir qualquer reclamação, para uma melhor análise do sistema.
4.	Implementação do banco de dados: Incluir os clientes no banco de dados, para obter informações e analisar a necessidade de cada cliente, para assim oferecer uma experiência boa e única para cada usuário, criando um sistema eficiente.


<i><h5> Atividade de requisitos </h5></i>
<hr>
Situação<br><br><br>
Um restaurante estabelece um sistema chamado garçom para o cadastro de clientes, onde ele poderá localizar por seu nome ou através dos atributos incluído no pedido, sendo possível comparar os dados entre os pedidos.<br><br>
Requisitos Funcionais<br><br>
•	Cadastro de clientes: Realiza o cadastro do cliente com os seguintes dados, nome e pedido;<br>
•	Cadastro de pedidos: Introduz os dados, numeroDaMesa, horaDoPedido, tipoDeGrao, tipoDeSalada, acompanhamento; 

<i><h5> Diagrama de Casos de Uso </h5></i>

<img src = "https://github.com/BrenerReis/Bertoti/issues/1#issue-1462628451">







  
